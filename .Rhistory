points(intersection_x, intersection_y, col = 'purple', pch = 19, cex = 1)
# Annotation du point
text(intersection_x, intersection_y,
labels = paste0("(", round(intersection_x, 1), ", ", round(intersection_y, 2), ")"),
pos = 4, col = 'purple', cex = 0.8)
# Ajout d'une légende
legend("bottomright",
legend = c('Puissance souhaitée', 'Puissance théorique', 'n minimal', 'Puissance empirique', 'Intersection'),
col = c('red', 'blue', 'darkgreen', 'black', 'purple'),
lty = c(1, 1, 2, 1, NA),
pch = c(NA, NA, NA, NA, 19),
cex = 0.8, bty = 'n', x.intersp = 0.4, seg.len = 0.8)
# Simulation de la puissance statistique en fonction de n
set.seed(123) # Pour garantir la reproductibilité
# Paramètres
num_simulations <- 1000    # Nombre de simulations Monte Carlo
mean_null <- 1             # Moyenne sous l'hypothèse nulle
std_dev <- 1               # Écart-type
effect_size <- 0.5         # Delta (différence entre les moyennes)
alpha <- 0.05              # Niveau de signification
beta <- 0.05       # Niveau de probabilité d'erreur de type II
mean_alternative <- mean_null + effect_size # Moyenne sous l'hypothèse alternative
# Calcul de la taille minimale de l'échantillon
n_min <- ((std_dev / effect_size) * (qnorm(1 - alpha) - qnorm(desired_beta)))^2
sample_sizes <- (n_min - 10):(n_min + 10) # Plage de tailles d'échantillon
# Initialisation des vecteurs pour stocker les résultats
empirical_power <- rep(NA, length(sample_sizes))  # Puissance empirique
theoretical_power <- rep(NA, length(sample_sizes)) # Puissance théorique
# Boucle sur les différentes tailles d'échantillon
for (index in seq_along(sample_sizes)) {
sample_size <- sample_sizes[index]
# Calcul de la puissance théorique
theoretical_power[index] <- 1 - pnorm(qnorm(1 - alpha) - (sqrt(sample_size) * effect_size) / std_dev)
# Génération des données pour les simulations
simulated_data <- matrix(rnorm(sample_size * num_simulations, mean = mean_alternative, sd = std_dev),
ncol = sample_size, nrow = num_simulations)
# Moyenne par échantillon
sample_means <- rowMeans(simulated_data)
# Statistique de test
test_statistics <- sqrt(sample_size) * (sample_means - mean_null) / std_dev
# Calcul de la proportion de rejets (puissance empirique)
valid_tests <- test_statistics[test_statistics > qnorm(1 - alpha)]
empirical_power[index] <- if (length(valid_tests) > 0) {
length(valid_tests) / num_simulations
} else {
0
}
}
# Tracé des résultats
plot(sample_sizes, empirical_power, type = 'b',
xlim = c(40, 50),
ylim = c(0.9, 1),
xlab = 'Taille de l\'échantillon (n)', ylab = 'Puissance',
main = 'Puissance statistique en fonction de n')
lines(sample_sizes, theoretical_power, col = 'blue', type = 'l')
abline(h = 1 - desired_beta, col = 'red', lwd = 2) # Ligne pour la puissance souhaitée
abline(v = n_min, col = 'darkgreen', lty = 2, lwd = 2) # Ligne pour n minimal
# Calcul des coordonnées de l'intersection
intersection_x <- n_min
intersection_y <- 1 - beta
# Ajout du point d'intersection
points(intersection_x, intersection_y, col = 'purple', pch = 19, cex = 1)
# Annotation du point
text(intersection_x, intersection_y,
labels = paste0("(", round(intersection_x, 1), ", ", round(intersection_y, 2), ")"),
pos = 4, col = 'purple', cex = 0.8)
# Ajout d'une légende
legend("bottomright",
legend = c('Puissance souhaitée', 'Puissance théorique', 'n minimal', 'Puissance empirique', 'Intersection'),
col = c('red', 'blue', 'darkgreen', 'black', 'purple'),
lty = c(1, 1, 2, 1, NA),
pch = c(NA, NA, NA, NA, 19),
cex = 0.8, bty = 'n', x.intersp = 0.4, seg.len = 0.8)
set.seed(42)
# Paramètres
m <- 1000
mu_0 <- 0
sigma <- 1
delta <- 0.5
alpha <- 0.05
mu_1 <- 0.5
mu_2 <- mu_1 + delta
beta <- 0.05
n_min_1 <- ((sigma / delta) * (qnorm(1 - alpha) - qnorm(beta)))^2
n_min_2 <- 2 * n_min_1
n_valeurs <- seq(floor(n_min_1 - 40), ceiling(n_min_1 + 45))
calc_pi_theo <- function(n, delta, sigma, alpha, one_sample = TRUE) {
factor <- ifelse(one_sample, 1, sqrt(2))
1 - pnorm(qnorm(1 - alpha) - (sqrt(n) * delta) / (factor * sigma))
}
simulate_puissance <- function(n, m, mu_1, mu_2, sigma, alpha, one_sample = TRUE) {
factor <- ifelse(one_sample, 1, sqrt(2))
X <- matrix(rnorm(n * m, mu_1, sigma), ncol = n, nrow = m)
if (one_sample) {
T_stats <- sqrt(n) * (rowMeans(X) - mu_0) / sigma
} else {
Y <- matrix(rnorm(n * m, mu_2, sigma), ncol = n, nrow = m)
T_stats <- sqrt(n) * (rowMeans(Y - X)) / (factor * sigma)
}
mean(T_stats > qnorm(1 - alpha))
}
# Calcul des puissances
pi_theo_1 <- sapply(n_valeurs, calc_pi_theo, delta = delta, sigma = sigma, alpha = alpha, one_sample = TRUE)
pi_theo_2 <- sapply(n_valeurs, calc_pi_theo, delta = delta, sigma = sigma, alpha = alpha, one_sample = FALSE)
pi_empirique_1 <- sapply(n_valeurs, simulate_puissance, m = m, mu_1 = mu_1, mu_2 = mu_2, sigma = sigma, alpha = alpha, one_sample = TRUE)
pi_empirique_2 <- sapply(n_valeurs, simulate_puissance, m = m, mu_1 = mu_1, mu_2 = mu_2, sigma = sigma, alpha = alpha, one_sample = FALSE)
# Graphique
plot(n_valeurs, pi_empirique_1, type = 'b', xlab = 'n', ylab = 'Puissance', ylim = c(0, 1),
main = "Comparaison des puissances (One-sample vs Two-sample)")
lines(n_valeurs, pi_empirique_2, type = 'b', col = 'purple')
lines(n_valeurs, pi_theo_1, col = 'blue', lwd = 2)
lines(n_valeurs, pi_theo_2, col = 'violet', lwd = 2)
abline(h = 0.95, col = 'red')
abline(v = n_min_1, col = 'blue', lty = 2, lwd = 2)
abline(v = n_min_2, col = 'violet', lty = 2, lwd = 2)
legend("bottomright", legend = c('Empirique (one-sample)', 'Empirique (two-sample)',
'Théorique (one-sample)', 'Théorique (two-sample)',
'Puissance désirée', 'n_min (one-sample)', 'n_min (two-sample)'),
col = c('black', 'purple', 'blue', 'violet', 'red', 'blue', 'violet'),
lty = c(1, 1, 1, 1, 1, 2, 2), bty = 'n', cex = 0.8)
y_point <- 1-beta
points(n_min_1, y_point, col = 'black', pch = 19, cex = 1)
points(n_min_2, y_point, col = 'black', pch = 19, cex = 1)
text(n_min_1, y_point,
labels = paste0("(", round(n_min_1, 1), ", ", round(y_point, 2), ")"),
pos = 4, col = 'purple', cex = 0.8)
text(n_min_2, y_point,
labels = paste0("(", round(n_min_2, 1), ", ", round(y_point, 2), ")"),
pos = 4, col = 'purple', cex = 0.8)
par(mfrow=c(1,3))
m <- 1000
sigma <- 1
alpha <- 0.05
mu_1 <- 1
n_values <- c(10, 100, 1000)
delta_values <- c(0.5, 1, 2)
theta_range <- 1
colors <- c('black', 'violet', 'skyblue')
for (delta in delta_values) {
theta_values <- c(seq(-delta - theta_range, -delta - 0.01, by = 0.01),
seq(delta + 0.01, delta + theta_range, by = 0.01))
alpha_risk_values <- matrix(NA, nrow = length(n_values), ncol = length(theta_values))
# Plot setup
plot(theta_values, rep(NA, length(theta_values)), type = "n",
xlab = expression(theta), ylab = "Alpha Risk",
xlim = c(min(theta_values), max(theta_values)),
ylim = c(0, 0.075),
main = paste("Alpha Risk pour delta =", delta))
for (n_index in 1:length(n_values)) {
n <- n_values[n_index]
lower_bound <- -delta + qnorm(1 - alpha) * (sqrt(2) * sigma) / sqrt(n)
upper_bound <- delta + qnorm(alpha) * (sqrt(2) * sigma) / sqrt(n)
for (theta_index in 1:length(theta_values)) {
theta <- theta_values[theta_index]
mu_2 <- mu_1 - theta
X <- matrix(rnorm(n * m, mu_1, sigma), ncol = n, nrow = m)
Y <- matrix(rnorm(n * m, mu_2, sigma), ncol = n, nrow = m)
X_mean <- apply(X, 1, mean)
Y_mean <- apply(Y, 1, mean)
mean_diff <- X_mean - Y_mean
valid_T <- mean_diff[mean_diff > lower_bound & mean_diff < upper_bound]
if (length(valid_T) > 0) {
alpha_risk_values[n_index, theta_index] <- length(valid_T) / m
} else {
alpha_risk_values[n_index, theta_index] <- 0
}
}
lines(theta_values, alpha_risk_values[n_index, ], type = 'p', col = colors[n_index])
}
abline(h = 0.02, col = 'red')
abline(v = -delta, col = 'blue', lty = 2)
abline(v = delta, col = 'blue', lty = 2)
legend("topright",
legend = c('Alpha risk n=10', 'Alpha risk n=100', 'Alpha risk n=1000',
'|x|=delta', 'Alpha risk désiré'),
col = c('black', 'violet', 'skyblue', 'blue', 'red'),
lty = c(1, 1, 1, 2, 1), bty = 'n', lwd = c(2, 2, 2, 2, 2),
cex = 0.8)
}
# Simulation de la puissance statistique en fonction de n
set.seed(123) # Pour garantir la reproductibilité
# Paramètres
num_simulations <- 1000    # Nombre de simulations Monte Carlo
mean_null <- 1             # Moyenne sous l'hypothèse nulle
std_dev <- 1               # Écart-type
effect_size <- 0.5         # Delta (différence entre les moyennes)
alpha <- 0.05              # Niveau de signification
beta <- 0.05       # Niveau de probabilité d'erreur de type II
mean_alternative <- mean_null + effect_size # Moyenne sous l'hypothèse alternative
# Calcul de la taille minimale de l'échantillon
n_min <- ((std_dev / effect_size) * (qnorm(1 - alpha) - qnorm(beta)))^2
sample_sizes <- (n_min - 10):(n_min + 10) # Plage de tailles d'échantillon
# Initialisation des vecteurs pour stocker les résultats
empirical_power <- rep(NA, length(sample_sizes))  # Puissance empirique
theoretical_power <- rep(NA, length(sample_sizes)) # Puissance théorique
# Boucle sur les différentes tailles d'échantillon
for (index in seq_along(sample_sizes)) {
sample_size <- sample_sizes[index]
# Calcul de la puissance théorique
theoretical_power[index] <- 1 - pnorm(qnorm(1 - alpha) - (sqrt(sample_size) * effect_size) / std_dev)
# Génération des données pour les simulations
simulated_data <- matrix(rnorm(sample_size * num_simulations, mean = mean_alternative, sd = std_dev),
ncol = sample_size, nrow = num_simulations)
# Moyenne par échantillon
sample_means <- rowMeans(simulated_data)
# Statistique de test
test_statistics <- sqrt(sample_size) * (sample_means - mean_null) / std_dev
# Calcul de la proportion de rejets (puissance empirique)
valid_tests <- test_statistics[test_statistics > qnorm(1 - alpha)]
empirical_power[index] <- if (length(valid_tests) > 0) {
length(valid_tests) / num_simulations
} else {
0
}
}
# Tracé des résultats
plot(sample_sizes, empirical_power, type = 'b',
xlim = c(40, 50),
ylim = c(0.9, 1),
xlab = 'Taille de l\'échantillon (n)', ylab = 'Puissance',
main = 'Puissance statistique en fonction de n')
lines(sample_sizes, theoretical_power, col = 'blue', type = 'l')
abline(h = 1 - beta, col = 'red', lwd = 2) # Ligne pour la puissance souhaitée
abline(v = n_min, col = 'darkgreen', lty = 2, lwd = 2) # Ligne pour n minimal
# Calcul des coordonnées de l'intersection
intersection_x <- n_min
intersection_y <- 1 - beta
# Ajout du point d'intersection
points(intersection_x, intersection_y, col = 'purple', pch = 19, cex = 1)
# Annotation du point
text(intersection_x, intersection_y,
labels = paste0("(", round(intersection_x, 1), ", ", round(intersection_y, 2), ")"),
pos = 4, col = 'purple', cex = 0.8)
# Ajout d'une légende
legend("bottomright",
legend = c('Puissance souhaitée', 'Puissance théorique', 'n minimal', 'Puissance empirique', 'Intersection'),
col = c('red', 'blue', 'darkgreen', 'black', 'purple'),
lty = c(1, 1, 2, 1, NA),
pch = c(NA, NA, NA, NA, 19),
cex = 0.8, bty = 'n', x.intersp = 0.4, seg.len = 0.8)
par(mfrow=c(1,3))
m <- 1000
sigma <- 1
alpha <- 0.05
mu_1 <- 1
n_values <- c(10, 100, 1000)
delta_values <- c(0.5, 1, 2)
theta_range <- 1
colors <- c('black', 'violet', 'skyblue')
for (delta in delta_values) {
theta_values <- c(seq(-delta - theta_range, -delta - 0.01, by = 0.01),
seq(delta + 0.01, delta + theta_range, by = 0.01))
alpha_risk_values <- matrix(NA, nrow = length(n_values), ncol = length(theta_values))
# Plot setup
plot(theta_values, rep(NA, length(theta_values)), type = "n",
xlab = expression(theta), ylab = "Alpha Risk",
xlim = c(min(theta_values), max(theta_values)),
ylim = c(0, 0.06),
main = paste("Alpha Risk pour delta =", delta))
for (n_index in 1:length(n_values)) {
n <- n_values[n_index]
lower_bound <- -delta + qnorm(1 - alpha) * (sqrt(2) * sigma) / sqrt(n)
upper_bound <- delta + qnorm(alpha) * (sqrt(2) * sigma) / sqrt(n)
for (theta_index in 1:length(theta_values)) {
theta <- theta_values[theta_index]
mu_2 <- mu_1 - theta
X <- matrix(rnorm(n * m, mu_1, sigma), ncol = n, nrow = m)
Y <- matrix(rnorm(n * m, mu_2, sigma), ncol = n, nrow = m)
X_mean <- apply(X, 1, mean)
Y_mean <- apply(Y, 1, mean)
mean_diff <- X_mean - Y_mean
valid_T <- mean_diff[mean_diff > lower_bound & mean_diff < upper_bound]
if (length(valid_T) > 0) {
alpha_risk_values[n_index, theta_index] <- length(valid_T) / m
} else {
alpha_risk_values[n_index, theta_index] <- 0
}
}
lines(theta_values, alpha_risk_values[n_index, ], type = 'p', col = colors[n_index])
}
abline(h = 0.02, col = 'red')
abline(v = -delta, col = 'blue', lty = 2)
abline(v = delta, col = 'blue', lty = 2)
legend("topright",
legend = c('Alpha risk n=10', 'Alpha risk n=100', 'Alpha risk n=1000',
'|x|=delta', 'Alpha risk désiré'),
col = c('black', 'violet', 'skyblue', 'blue', 'red'),
lty = c(1, 1, 1, 2, 1), bty = 'n', lwd = c(2, 2, 2, 2, 2),
cex = 0.8)
}
setwd("~/github/projet_diversite_inclusion_entreprise")
data <- read.csv2("data/promotions.csv")
data <- read.csv2("data/promotion.csv")
View(data)
# Charger les données
statut <- read.csv("data/promotion.csv", sep = ";")
# Filtrer pour garder uniquement les lignes où 'Indicateur' est égal à 'Rémunération mensuelle moyenne brute'
statut <- statut[statut$Indicateur == "Rémunération mensuelle moyenne brute", ]
# Filtrer pour conserver les lignes où 'Plage M3E' est NA
statut <- statut[is.na(statut$Plage.M3E), ]
# Supprimer les colonnes non nécessaires
statut <- subset(statut, select = -c(
Perimetre.juridique, Perimetre.spatial,
Spatial.perimeter, Indicateur, Indicator,
Type.of.contract, Employee.category, Plage.M3E,
M3E.classification, Gender, Unité, Unit,
Chapitre.du.bilan.social
))
# Charger les données
statut <- read.csv("data/promotion.csv", sep = ";")
# Filtrer pour garder uniquement les lignes où 'Indicateur' est égal à 'Rémunération mensuelle moyenne brute'
statut <- statut[statut$Indicateur == "Rémunération mensuelle moyenne brute", ]
# Filtrer pour conserver les lignes où 'Plage M3E' est NA
statut <- statut[is.na(statut$Plage.M3E), ]
# Supprimer les colonnes non nécessaires
statut <- subset(statut, select = -c(
Perimètre.juridique, Perimètre.spatial,
Spatial.perimeter, Indicateur, Indicator,
Type.of.contract, Employee.category, Plage.M3E,
M3E.classification, Gender, Unité, Unit,
Chapitre.du.bilan.social
))
# Grouper par "Année", "Type de contrat" et "Collège", puis calculer la somme de "Valeur"
library(dplyr)
statut <- statut %>%
group_by(Année, Type.de.contrat, Collège) %>%
summarise(Salaire.mensuel.brut.moyen = sum(Valeur, na.rm = TRUE)) %>%
ungroup()
# Afficher le résultat
statut
View(statut)
# Charger les données
statut <- read.csv("data/promotion.csv", sep = ";")
# Filtrer pour garder uniquement les lignes où 'Indicateur' est égal à 'Rémunération mensuelle moyenne brute'
statut <- statut[statut$Indicateur == "Rémunération mensuelle moyenne brute", ]
# Filtrer pour conserver les lignes où 'Plage M3E' est NA
statut <- statut[is.na(statut$Plage.M3E), ]
# Supprimer les colonnes non nécessaires
statut <- subset(statut, select = -c(
Perimètre.juridique, Perimètre.spatial,
Spatial.perimeter, Indicateur, Indicator,
Type.of.contract, Employee.category, Plage.M3E,
M3E.classification, Gender, Unité, Unit,
Chapitre.du.bilan.social
))
statut
View(statut)
# Charger les données
statut <- read.csv("data/promotion.csv", sep = ";")
# Filtrer pour garder uniquement les lignes où 'Indicateur' est égal à 'Rémunération mensuelle moyenne brute'
statut <- statut[statut$Indicateur == "Rémunération mensuelle moyenne brute", ]
# Filtrer pour conserver les lignes où 'Plage M3E' est NA
statut <- statut[is.na(statut$Plage.M3E), ]
statut
View(statut)
# Charger les données
statut <- read.csv2("data/promotion.csv")
# Filtrer pour garder uniquement les lignes où 'Indicateur' est égal à 'Rémunération mensuelle moyenne brute'
statut <- statut[statut$Indicateur == "Rémunération mensuelle moyenne brute",]
# Filtrer pour conserver les lignes où 'Plage M3E' est NA
statut <- statut[is.na(statut$Plage.M3E), ]
# Supprimer les colonnes non nécessaires
statut <- subset(statut, select = -c(
Perimètre.juridique, Perimètre.spatial,
Spatial.perimeter, Indicateur, Indicator,
Type.of.contract, Employee.category, Plage.M3E,
M3E.classification, Gender, Unité, Unit,
Chapitre.du.bilan.social
))
# Grouper par "Année", "Type de contrat" et "Collège", puis calculer la somme de "Valeur"
library(dplyr)
statut <- statut %>%
group_by(Année, Type.de.contrat, Collège) %>%
summarise(Salaire.mensuel.brut.moyen = sum(Valeur, na.rm = TRUE)) %>%
ungroup()
# Charger les données
statut <- read.csv2("data/promotion.csv")
# Filtrer pour garder uniquement les lignes où 'Indicateur' est égal à 'Rémunération mensuelle moyenne brute'
statut <- statut[statut$Indicateur == "Rémunération mensuelle moyenne brute",]
# Charger les données
statut <- read.csv2("data/promotion.csv")
# Filtrer pour garder uniquement les lignes où 'Indicateur' est égal à 'Rémunération mensuelle moyenne brute'
statut <- statut[statut$Indicateur == "Rémunération mensuelle moyenne brute",]
# Filtrer pour conserver les lignes où 'Plage M3E' est NA
statut <- statut[is.na(statut$Plage.M3E), ]
# Charger les données
statut <- read.csv2("data/promotion.csv")
# Filtrer pour garder uniquement les lignes où 'Indicateur' est égal à 'Rémunération mensuelle moyenne brute'
statut <- statut[statut$Indicateur == "Rémunération mensuelle moyenne brute",]
# Filtrer pour conserver les lignes où 'Plage M3E' est NA
statut <- statut[statut$Plage.M3E == "", ]
# Supprimer les colonnes non nécessaires
statut <- subset(statut, select = -c(
Perimètre.juridique, Perimètre.spatial,
Spatial.perimeter, Indicateur, Indicator,
Type.of.contract, Employee.category, Plage.M3E,
M3E.classification, Gender, Unité, Unit,
Chapitre.du.bilan.social
))
# Grouper par "Année", "Type de contrat" et "Collège", puis calculer la somme de "Valeur"
library(dplyr)
statut <- statut %>%
group_by(Année, Type.de.contrat, Collège) %>%
summarise(Salaire.mensuel.brut.moyen = sum(Valeur, na.rm = TRUE)) %>%
ungroup()
View(statut)
# Charger les données
statut <- read.csv2("data/promotion.csv")
# Filtrer pour garder uniquement les lignes où 'Indicateur' est égal à 'Rémunération mensuelle moyenne brute'
statut <- statut[statut$Indicateur == "Rémunération mensuelle moyenne brute",]
# Filtrer pour conserver les lignes où 'Plage M3E' est NA
statut <- statut[statut$Plage.M3E == "", ]
# Supprimer les colonnes non nécessaires
statut <- subset(statut, select = -c(
Perimètre.juridique, Perimètre.spatial,
Spatial.perimeter, Indicateur, Indicator,
Type.of.contract, Employee.category, Plage.M3E,
M3E.classification, Gender, Unité, Unit,
Chapitre.du.bilan.social
))
# Afficher le résultat
statut
View(statut)
# Charger les données
statut <- read.xlsx("data/egalite.xlsx")
# Charger les données
statut <- readxlsx("data/egalite.xlsx")
# Charger les données
statut <- read.xls("data/egalite.xlsx")
# Charger les données
statut <- read.xl("data/egalite.xlsx")
# Charger les données
statut <- readxl("data/egalite.xlsx")
??readxl
?readxl
# Charger les données
statut <- read_excel("data/egalite.xlsx")
library("readxl")
# Charger les données
statut <- read_excel("data/egalite.xlsx")
View(statut)
View(data)
library("readxl")
# Charger les données
statut <- read_excel("data/egalite.xlsx")
View(statut)
statut = statut[statut$Année == 2020]
View(statut)
View(statut)
View(statut)
library("readxl")
# Charger les données
statut <- read_excel("data/egalite.xlsx")
statut = statut[statut$Année == "2020"]
View(statut)
library("readxl")
# Charger les données
statut <- read_excel("data/egalite.xlsx")
statut = statut[statut$Année == 2020]
View(statut)
library("readxl")
# Charger les données
egalite <- read_excel("data/egalite.xlsx")
egalite = egalite[egalite$Année == 2020,]
View(egalite)
library("readxl")
# Charger les données
egalite <- read_excel("data/egalite.xlsx")
egalite = egalite[egalite$Année == 2020,]
egalite = egalite[egalite$`Code NAF` == "35.11Z - Production d'électricité"]
View(egalite)
library("readxl")
# Charger les données
egalite <- read_excel("data/egalite.xlsx")
egalite = egalite[egalite$Année == 2020,]
egalite = egalite[egalite$`Code NAF` == "35.11Z - Production d\'électricité"]
library("readxl")
# Charger les données
egalite <- read_excel("data/egalite.xlsx")
egalite = egalite[egalite$Année == 2020,]
egalite = egalite[egalite$'Code NAF' == "35.11Z - Production d'électricité"]
library("readxl")
# Charger les données
egalite <- read_excel("data/egalite.xlsx")
egalite = egalite[egalite$Année == 2020,]
egalite = egalite[egalite$`Code NAF` == "35.11Z - Production d'électricité", ]
View(egalite)
library("readxl")
# Charger les données
egalite <- read_excel("data/egalite.xlsx")
egalite = egalite[egalite$Année == 2020,]
egalite = egalite[egalite$`Code NAF` == "35.11Z - Production d'électricité", ]
write.csv2(egalite, "data\egalite.csv")
library("readxl")
# Charger les données
egalite <- read_excel("data/egalite.xlsx")
egalite = egalite[egalite$Année == 2020,]
egalite = egalite[egalite$`Code NAF` == "35.11Z - Production d'électricité", ]
?write.csv
write.csv2(egalite, "data\egalite.csv")
write.csv2(egalite, file = "data\egalite.csv")
write.csv(egalite, file = "data\egalite.csv")
write.table(egalite, file = "egalite")
write.csv(egalite, file = "egalite")
write.csv(egalite, file = "egalite.csv")
data <- read.csv("egalite.csv")
View(data)
library("readxl")
# Charger les données
egalite <- read_excel("data/egalite.xlsx")
egalite = egalite[egalite$Année == 2019,]
egalite = egalite[egalite$`Code NAF` == "35.11Z - Production d'électricité", ]
